@import com.geirsson.reavealjs.RevealJs._

@slide
  @h2
    @img(src := "img/bloop.png", style := "border: none; box-shadow: none; width: 60%")
@slide
  @h3
    @img(style := "border: none; width: 30%; box-shadow: none;", src:="img/jvican.jpg")
    @br
    Jorge @twitter
  @ul
    @li
      Devtools for ~2.5 years at @organization
      @ul
        @li
          I co-maintain Scala's incremental compiler (Zinc)
        @li
          I work on build tools and build servers
        @li
          @code{scalac}, compiler plugins and infrastructure

    @li
      @b{Obsession}: developer productivity
@slide
  @h3
    About Martin

  @p
    bla bla

  @p
    bla bla

@slide
  @h3
    @b{Productivity}: any task you do is bound by the speed of your thinking process, not the tools you use.

@slide
  @h3
    @b{Minimize} the amount of time it passes between a change in the code and an execution result.

@slide
  @img(src := "img/build-tools-monsters.png", style := "border: none; box-shadow: none; width: 100%")

@slide
  @img(src := "img/bloop-logo2.png", style := "border: none; box-shadow: none; width: 90%")

@slide
  @h1
    @b{Compilation server}
  @h3
    "The new fawn in the block"

@slide
  @h2
    @b{Old architecture}

  @dotty
    "Build tool A" -> "Compiler A";
    "Other CLI tools" -> "Compiler B";
    "IDE" -> "Compiler C";

@slide
  @h2
    @b{New architecture}

  @dotty
    "Build tool A" -> "Bloop";
    "Other CLI tools" -> "Bloop";
    "IDE" -> "Bloop";

@slide
  @h2
    @b{Hot} compilers
  @h4
    What is that?

  @img(src := "img/hot-compiler.jpg", style := "border: none; box-shadow: none; width: 60%")

@slide
  @h3
    Why being @b{hot} is important ðŸ•ºðŸ’ƒ
  @h4
    @ul
      @li
        Performance diff against cold compilers is critical.
      @li
        Compilers are re-used by different tools.
      @li
        We kill hot compilers more often than we think.
        @ul
          @li
            @code{sbt> reload}
          @li
            Killing accidentally the build tool.
          @li
            Every time we use sbt in different builds concurrently.

@slide
  @h2
    @b{Hot} vs @b{Cold}
  @h4
    Benchmarks in @lnk("Grafana.", "https://scala-ci.typesafe.com/grafana/dashboard/db/hot-vs-cold?orgId=1")
  @br
  @ul
    @li
      Cold compilation can be up to 18x slower!
    @li
      Hot'ting the JVM is expensive, it takes:
        @ul
          @li
            CPU cycles, RAM, power (battery)...

@slide
  @h2
    @img(src := "img/poor-rick.png", style := "border: none; box-shadow: none; width: 50%")

@slide
  @h2
    Centralization
  @h4
    @blockquote
      @strong
        "One server to compile them all"
  @h4
    @hl.diff
      --- a/nothing.properties
      +++ b/bloop.properties
      - build.tool.specific=true
      - one.time.effort=false
      - shared.code=false
      - robust=false
      - easier.to.maintain=false
      - easier.to.test=false
      - bigger.impact=false
      + build.tool.specific=false
      + one.time.effort=true
      + shared.code=true
      + robust=true
      + easier.to.maintain=true
      + easier.to.test=true
      + bigger.impact=true

@slide
  @h2
    Integrations I
  @h3
    @b{Paramount} for adoption.
  @img(src := "img/rick-morty-crying.png", style := "border: none; box-shadow: none; width: 70%")

@slide
  @h2
    Integrations II
  @br
  @ul
    @li
      @fragment
      Supports Scala 2 and future Scala 3.
    @li
      @fragment
      Build-tool-agnostic:
      @ul
        @li
          Currently: sbt (0.13 and 1.0), maven.
        @li
          Future: bazel, gradle, pants.

@slide
  @h2
    Integrations III
  @br
  @ul
    @li
      @fragment
      Command-line tool frontend
    @li
      Enables creation of new tools
      @ul
        @li
          Ninja/make-based build infrastructure
        @li
          Writing scripts is easy and performant
        @li
          Encourages experimentation

@slide
  @h2
    Integrations IIII
  @h3
    Build Server Protocol
  @br
  @ul
    @li
      @fragment
      Developed at the Scala Center
    @li
      @fragment
      An LSP-like protocol to communicate with build tools
    @li
      @fragment
      More info at "Build Server Protocol and new IDEAs"
      @ul
        @li
          Presented by Jorge and Justin at Scalasphere 2018
        @li
          Store behind BSP and IntelliJ integration

@slide
  @h2
    New use cases
  @ul
    @li
      @fragment
      Better caching opportunities
      @ul
        @li
          In-memory over writing to disk
        @li
          Needs invalidation logic
    @li
      @fragment
      Remote compilation, requires:
      @ul
        @li
          Independence of compile processes
        @li
          Deduplication of compile requests

    @li
      @fragment
      Pipelined compilation
        @ul
          @li
            Idea by Rory Graves (2017)

@slide
  @h1
    Benchmarks
  @br

  @ul
    @li
      Our build tools take a long time to start up

    @li
      sbt/sbt: xxx seconds

    @li
      guardian/frontend: xxx seconds

    @li
      scala/scala: xxx seconds

@slide
  @h3
    We're throwing away the JVM's job!

  @ul
    @li
      The JVM works hard to optimize code as it runs.

    @li
      Optimized/JITted compiler can be up to 20x faster!

    @li
      We should never discard those "hot" compilers.

    @li
      Restarting or reloading sbt throws away your hot compilers.

@slide
  @h3
    We're duplicating work!

  @ul
    @li
      IDEs continuously compile our code to give us diagnostics

    @li
      Our build tools compile our code too

    @li
      Why do they do the job twice?

    @li
      Can't they at least share some parts?

@slide
  @h3
    Bloop is our solution.

@slide
  @h3
    But...

@slide
  @h3
    Adopting a new tool is hard

  @ul
    @li
      Adoption depends on ease of use.

    @li
      Developers don't want to lear new tools.

    @li
      Habits are hard to change.

@slide
  @h3
    New tools should integrate seamlessly in developers' workflow.

@slide
  @h3
    Integrations

  @ul
    @li
      Bloop implements the Build Server Protocol (BSP)

    @li
      BSP describes how a client can get infos about a build

    @li
      It is inspired by LSP

    @li
      More infos in Jorge's and Justin's talk at ScalaSphere 2018

@slide
  @h3
    A new architecture

  @p
    // Graph...

  @ul
    @li
      Both build tools and IDEs communicate with the BSP server

    @li
      They delegate compilation, etc. to the BSP server.

@slide
  @h3
    Remote compilation

  @ul
    @li
      Compilation jobs can be delegated to powerful, remote clusters

    @li
      ...

@slide
  @h3
    Pipelined compilation

  @ul
    @li
      ...

@slide
  @h1
    Benchmarks

@slide
  @cite
    "Bloop is awesome"

@slide
  @h1
    Demo

@import com.geirsson.reavealjs.RevealJs._

@slide
  @h2
    @img(src := "img/bloop.png", style := "border: none; box-shadow: none; width: 60%")

@slide
  @h3
    @img(style := "border: none; width: 30%; box-shadow: none;", src:="img/jvican.jpg")
    @br
    Jorge @twitter
  @ul
    @li
      Devtools for ~2.5 years at @organization
      @ul
        @li
          I co-maintain Scala's incremental compiler (Zinc)
        @li
          I work on build tools and build servers
        @li
          @code{scalac}, compiler plugins and infrastructure

    @li
      @b{Obsession}: developer productivity
@slide
  @h3
    @img(style := "border: none; width: 30%; box-shadow: none;", src := "img/martin.jpg")
    @br
    Martin @mtwitter

  @ul
    @li
      Software engineer at @organization since March 2017
      @ul
        @li
          I work on compilers and build tools.
        @li
          I don't like it when tools get in my way.
        @li
          Worked on sbt, Zinc, Scala Native and now Dotty.

    @li
      @b{Obsession}: Build tool agnosticity

@slide
  @h3
    @b{Productivity}: any task you do is bound by the speed of your thinking process, not the tools you use.

@slide
  @h3
    @b{Minimize} the amount of time it passes between a change in the code and an execution result.

@slide
  @img(src := "img/build-tools-monsters.png", style := "border: none; box-shadow: none; width: 100%")

@slide
  @img(src := "img/bloop-logo2.png", style := "border: none; box-shadow: none; width: 90%")

@slide
  @h1
    @b{Compilation server}
  @h3
    "The new fawn in the block"

@slide
  @h2
    @b{Old architecture}

  @dotty
    "Build tool A" -> "Compiler A";
    "Other CLI tools" -> "Compiler B";
    "IDE" -> "Compiler C";

@slide
  @h2
    @b{New architecture}

  @dotty
    "Build tool A" -> "Bloop";
    "Other CLI tools" -> "Bloop";
    "IDE" -> "Bloop";

@slide
  @h2
    @b{Hot} compilers
  @h4
    What is that?

  @img(src := "img/hot-compiler.jpg", style := "border: none; box-shadow: none; width: 60%")

@slide
  @h3
    Why being @b{hot} is important ðŸ•ºðŸ’ƒ
  @h4
    @ul
      @li
        Performance diff against cold compilers is critical.
      @li
        Compilers are re-used by different tools.
      @li
        We kill hot compilers more often than we think.
        @ul
          @li
            @code{sbt> reload}
          @li
            Killing accidentally the build tool.
          @li
            Every time we use sbt in different builds concurrently.

@slide
  @h2
    @b{Hot} vs @b{Cold}
  @h4
    Benchmarks in @lnk("grafana.", "https://scala-ci.typesafe.com/grafana/dashboard/db/hot-vs-cold?orgid=1")
  @br
  @ul
    @li
      Cold compilation can be up to 18x slower!
    @li
      Hot'ting the JVM is expensive, it takes:
        @ul
          @li
            CPU cycles, RAM, power (battery)...

@slide
  @h2
    @img(src := "img/poor-rick.png", style := "border: none; box-shadow: none; width: 50%")

@slide
  @h2
    Centralization
  @h4
    @blockquote
      @strong
        "One server to compile them all"
  @h4
    @hl.diff
      --- a/nothing.properties
      +++ b/bloop.properties
      - build.tool.specific=true
      - one.time.effort=false
      - shared.code=false
      - robust=false
      - easier.to.maintain=false
      - easier.to.test=false
      - bigger.impact=false
      + build.tool.specific=false
      + one.time.effort=true
      + shared.code=true
      + robust=true
      + easier.to.maintain=true
      + easier.to.test=true
      + bigger.impact=true

@slide
  @h2
    Integrations
  @h3
    @b{Paramount} for adoption.
  @img(src := "img/rick-morty-crying.png", style := "border: none; box-shadow: none; width: 70%")

@slide
  @blockquote
     Â«We created bloop to primarily support all the existing build tools that companies and Scala open-source developers use today.Â»
      @br
      @p
        @(fontSize := "0.75em")
        -- Us

@slide
  @h2
    Integrations
  @br
  @ul
    @li
      @fragment
      Supports Scala 2 and future Scala 3.
    @li
      @fragment
      Supports Scala.js and Scala Native (@lnk("open PR", "https://github.com/scalacenter/bloop/pull/485"))
    @li
      @fragment
      Build-tool-agnostic:
      @ul
        @li
          Currently: sbt, maven.
        @li
          Future: bazel, gradle, pants and more!

@slide
  @h2
    Integrations
  @h3
    A command-line tool interface
  @ul
    @li
      @fragment
      Ensures snappy developer workflow

    @li
      @fragment
      Use the shell you know and love.

    @li
      @fragment
      Benefit from awesome @code{tab}-completion

      @p
        @img(src := "img/tab-completion.gif", style := "border: none; box-shadow: none; al")

@slide
  @h2
    Integrations
  @h3
    Configuration file

  @ul
    @li
      Transparent, well-specified configuration file
      @hl.diff
        {
          "project": {
            "name": "mini-bloop",
            "sources": [ "/projects/mini-bloop/src/main/scala" ],
            "dependencies": [ "my-other-project" ],
            "classpath": [ "(...)/2.12.6/scala-library-2.12.6.jar" ],
            "classesDir": "/projects/mini-bloop/.bloop/mini-bloop/scala-2.12/classes",
            "scala": { "version" : "2.12.6", (...) }
            (...)
        }

    @li
      @fragment
      Query build information from the project files.
    @li
      @fragment
      Create a Ninja/Make-based build tool.
    @li
      @fragment
      Write easy and performant scripts.

@slide
  @blockquote
     Â«In the common use case when someone is working on a customer plugin in one build and wanting to iterate on core tooling the turns arounds are seconds instead of 10+ minutes.Â»
      @br
      @p
        @(fontSize := "0.75em")
        -- Happy Bloop user

@slide
  @h2
    Build Server Protocol (@strong{BSP})
  @ul
    @li
      @fragment
      Another way of integration with Bloop.
    @li
      @fragment
      An LSP-like protocol to communicate with build tools.
    @li
      @fragment
      Clients are language servers and editors.
    @li
      @fragment
      More at "@lnk("Build Server Protocol and new IDEAs", "https://scala.sphere.it/")"
      @ul
        @li
          Presented by Jorge and Justin at @b{Scalasphere 2018}

@slide
  @h2
    Build Server Protocol
  @h3
    Use cases
  @ul
    @li
      @fragment
      Efficient @code{~compile} or @code{~test} from IntelliJ
    @li
      @fragment
      Editors notify modified files directly to the build tool
    @li
      @fragment
      Better integration with build tools
      @ul
        @li
          sbt, maven, bazel, et cetera

@slide
  @h2
    Pioneering use cases
  @h3
    @strong{Better optimization opportunities}
  @ul
    @li
      Knowledge about build graph enables
      @ul
        @li
          In-memory storage over writing to disk/SSD
        @li
          File watching files to invalidate caches across builds
        @li
          Parallel compilation bookkeeping (classpath or source hashing)

@slide
  @h2
    Pioneering use cases
  @h3
    @strong{Remote compilation}
  @ul
    @li
      @fragment
      Popular use case for CI servers
    @li
      @fragment
      Keep cloud instances alive for compilation jobs
    @li
      @fragment
      Requires architectural changes:
      @ul
        @li
          Independence of compile processes @br
        @li
          Deduplication of compile requests @br

@slide
  @h2
    Pioneering use cases
  @h3
    @strong{Pipelined compilation}
  @h4
    @ul
      @li
        @fragment
        Pitched in by Rory Graves at Scalasphere 2017
      @li
        @fragment
        High impact for any build graph!
      @li
        @fragment
        Restricted gains when Java compilation is required
      @li
        @fragment
        Implemented in Zinc and Bloop (for now)

@slide
  @h3
    Timeline
  @h4
    @img(src := "img/pipelined-timeline.png", style := "border: none; box-shadow: none; width: 80%")

@slide
  @h1
    Compilation @strong{benchmarks}

@slide
  @h2
    @code{sbt/sbt}

  @h3
    @b{25% faster}

  @ul
    @li
      The Scala ecosystem's build tool.

    @li
      Small to medium project

    @li
      @b{800} source files, @b{50,000} lines of code, @b{20} modules

    @li
      Compiles in @b{38.05} s with sbt, or @b{28.47} s with Bloop

@slide
  @h2
    @code{guardian/frontend}

  @h3
    @b{28% faster}

  @ul
    @li
      The source for theguardian.com.

    @li
      Medium-sized project.

    @li
      @b{1,800} source files, @b{180,000} lines of code, @b{18} modules.

    @li
      Compiles in @b{88.62} s with sbt, or @b{63.42} s.

@slide
  @h2
    @code{akka/akka}

  @h3
    @b{19% faster}

  @ul
    @li
      Toolkit for building concurrent, distributed applications.

    @li
      Large project.

    @li
      @b{1,800} source files, @b{330,000} lines of code, @b{36} modules.

    @li
      Compiles in @b{263.7} s with sbt, or @b{215.7} s.

@slide
  @h2
    @code{apache/spark}

  @h3
    @b{28% faster}

  @ul
    @li
      Cluster computing system for Big Data.

    @li
      Large project.

    @li
      @b{1,800} source files, @b{400,000} lines of code, @b{24} modules.

    @li
      Compiles in @b{238.24} s with sbt, or @b{171.48} s

@slide
  @h3
    Benchmarks

  @img(src := "img/bench-charts.png", style := "border: none; box-shadow: none")

@import com.geirsson.reavealjs.RevealJs._

@slide
  @h2
    @img(src := "img/bloop.png", style := "border: none; box-shadow: none; width: 60%")

@slide
  @h3
    @img(style := "border: none; width: 30%; box-shadow: none;", src:="img/jvican.jpg")
    @br
    Jorge @twitter
  @ul
    @li
      Devtools for ~2.5 years at @organization
      @ul
        @li
          I co-maintain Scala's incremental compiler (Zinc)
        @li
          I work on build tools and build servers
        @li
          @code{scalac}, compiler plugins and infrastructure

    @li
      @b{Obsession}: developer productivity
@slide
  @h3
    @img(style := "border: none; width: 30%; box-shadow: none;", src := "img/martin.jpg")
    @br
    Martin @mtwitter

  @ul
    @li
      Software engineer at @organization since March 2017
      @ul
        @li
          I work on compilers and build tools.
        @li
          I don't like it when tools get in my way.
        @li
          Worked on sbt, Zinc, Scala Native and now Dotty.

    @li
      @b{Obsession}: Build tool agnosticity

@slide
  @h3
    @b{Productivity}: any task you do is bound by the speed of your thinking process, not the tools you use.

@slide
  @h3
    @b{Minimize} the amount of time it passes between a change in the code and an execution result.

@slide
  @img(src := "img/build-tools-monsters.png", style := "border: none; box-shadow: none; width: 100%")

@slide
  @img(src := "img/bloop-logo2.png", style := "border: none; box-shadow: none; width: 90%")

@slide
  @h1
    @b{Compilation server}
  @h3
    "The new fawn in the block"

@slide
  @h2
    @b{Old architecture}

  @dotty
    "Build tool A" -> "Compiler A";
    "Other CLI tools" -> "Compiler B";
    "IDE" -> "Compiler C";

@slide
  @h2
    @b{New architecture}

  @dotty
    "Build tool A" -> "Bloop";
    "Other CLI tools" -> "Bloop";
    "IDE" -> "Bloop";

@slide
  @h2
    @b{Hot} compilers
  @h4
    What is that?

  @img(src := "img/hot-compiler.jpg", style := "border: none; box-shadow: none; width: 60%")

@slide
  @h3
    Why being @b{hot} is important ðŸ•ºðŸ’ƒ
  @h4
    @ul
      @li
        Performance diff against cold compilers is critical.
      @li
        Compilers are re-used by different tools.
      @li
        We kill hot compilers more often than we think.
        @ul
          @li
            @code{sbt> reload}
          @li
            Killing accidentally the build tool.
          @li
            Every time we use sbt in different builds concurrently.

@slide
  @h2
    @b{Hot} vs @b{Cold}
  @h4
    Benchmarks in @lnk("grafana.", "https://scala-ci.typesafe.com/grafana/dashboard/db/hot-vs-cold?orgid=1")
  @br
  @ul
    @li
      Cold compilation can be up to 18x slower!
    @li
      Hot'ting the JVM is expensive, it takes:
        @ul
          @li
            CPU cycles, RAM, power (battery)...

@slide
  @h2
    @img(src := "img/poor-rick.png", style := "border: none; box-shadow: none; width: 50%")

@slide
  @h2
    Centralization
  @h4
    @blockquote
      @strong
        "One server to compile them all"
  @h4
    @hl.diff
      --- a/nothing.properties
      +++ b/bloop.properties
      - build.tool.specific=true
      - one.time.effort=false
      - shared.code=false
      - robust=false
      - easier.to.maintain=false
      - easier.to.test=false
      - bigger.impact=false
      + build.tool.specific=false
      + one.time.effort=true
      + shared.code=true
      + robust=true
      + easier.to.maintain=true
      + easier.to.test=true
      + bigger.impact=true

@slide
  @h2
    Integrations I
  @h3
    @b{Paramount} for adoption.
  @img(src := "img/rick-morty-crying.png", style := "border: none; box-shadow: none; width: 70%")

@slide
  @blockquote
     Â«We created bloop to primarily support all the existing build tools that companies and Scala open-source developers use today.Â»
      @br
      @p
        @(fontSize := "0.75em")
        -- Us

@slide
  @h2
    Integrations II
  @br
  @ul
    @li
      @fragment
      Supports Scala 2 and future Scala 3.
    @li
      @fragment
      Supports Scala.js and Scala Native (@lnk("open PR", "https://github.com/scalacenter/bloop/pull/485"))
    @li
      @fragment
      Build-tool-agnostic:
      @ul
        @li
          Currently: sbt (0.13 and 1.0), maven.
        @li
          Future: bazel, gradle, pants and more!

@slide
  @h2
    Integrations III
  @h3
    A command-line tool interface
  @ul
    @li
      @fragment
      Ensures snappy developer workflow
    @li
      @fragment
      Well-specified configuration format for projects.
      @ul
        @li
          @fragment
          Query build information from the project files.
        @li
          @fragment
          Create a Ninja/Make-based build tool.
        @li
          @fragment
          Write easy and performant scripts.

@slide
  @blockquote
     Â«In the common use case when someone is working on a customer plugin in one build and wanting to iterate on core tooling the turns arounds are seconds instead of 10+ minutes.Â»
      @br
      @p
        @(fontSize := "0.75em")
        -- Happy Bloop user

@slide
  @h2
    Integrations IV
  @h3
    Build Server Protocol (@strong{BSP})
  @ul
    @li
      @fragment
      An LSP-like protocol to communicate with build tools.
    @li
      @fragment
      Clients are language servers and editors.
    @li
      @fragment
      More at "@lnk("Build Server Protocol and new IDEAs", "https://scala.sphere.it/")"
      @ul
        @li
          Presented by Jorge and Justin at @b{Scalasphere 2018}
        @li
          Demo of IntelliJ compiling with Bloop

@slide
  @h2
    New use cases
  @ul
    @li
      @fragment
      Better caching opportunities
      @ul
        @li
          In-memory over writing to disk
        @li
          Needs invalidation logic
    @li
      @fragment
      Remote compilation, requires:
      @ul
        @li
          Independence of compile processes
        @li
          Deduplication of compile requests

    @li
      @fragment
      Pipelined compilation
        @ul
          @li
            Idea by Rory Graves (2017)
          @li
            Implementation for Zinc and Bloop (for now).

@slide
  @h3
    Benchmarking Bloop: sbt/sbt

  @ul
    @li
      @lnk("sbt/sbt", "https://github.com/sbt/sbt") is the Scala ecosystem's build tool.

    @li
      @b{852} source files, @b{51,408} lines of code, @b{20} modules.

    @li
      Compiles in @b{38.05} s with sbt, or @b{28.47} s (@b{75%}) in Bloop.

@slide
  @h3
    Benchmarking Bloop: guardian/frontend

  @ul
    @li
      @lnk("guardian/frontend", "https://github.com/guardian/frontend") is the source for
      theguardian.com.

    @li
      @b{1,750} source files, @b{175,628} lines of code, @b{18} modules.

    @li
      Compiles in @b{88.62} s with sbt, or @b{63.42} s (@b{72%}) in Bloop.

@slide
  @h3
    Benchmarking Bloop: akka/akka

  @ul
    @li
      @lnk("akka/akka", "https://github.com/akka/akka") is a toolkit for building concurrent apps.

    @li
      @b{1,775} source files, @b{330,555} lines of code, @b{36} modules.

    @li
      Compiles in @b{263.7} s with sbt, or @b{215.7} s (@b{81%}) in Bloop.

@slide
  @h3
    Benchmarking Bloop: apache/spark

  @ul
    @li
      @lnk("apache/spark", "https://github.com/apache/spark") is a cluster computing system for Big
      Data.

    @li
      @b{1,805} source files, @b{390,721} lines of code, @b{24} modules.

    @li
      Compiles in @b{238.24} s with sbt, or @b{171.48} s (@b{72%}) in Bloop.

@import com.geirsson.reavealjs.RevealJs._

@slide
  @h2
    @img(src := "img/bloop.png", style := "border: none; box-shadow: none; width: 60%")

@slide
  @h3
    @img(style := "border: none; width: 30%; box-shadow: none;", src:="img/jvican.jpg")
    @br
    Jorge @twitter
  @ul
    @li
      Devtools for ~2.5 years at @organization
      @ul
        @li
          I co-maintain Scala's incremental compiler (Zinc)
        @li
          I work on build tools and build servers
        @li
          @code{scalac}, compiler plugins and infrastructure

    @li
      @b{Obsession}: developer productivity
@slide
  @h3
    @img(style := "border: none; width: 30%; box-shadow: none;", src := "img/martin.jpg")
    @br
    Martin @mtwitter

  @ul
    @li
      Software engineer at @organization since March 2017
      @ul
        @li
          I work on compilers and build tools.
        @li
          I don't like it when tools get in my way.
        @li
          Worked on sbt, Zinc, Scala Native and now Dotty.

    @li
      @b{Obsession}: Build tool agnosticity

@slide
  @h3
    @b{Productivity}: any task you do is bound by the speed of your thinking process, not the tools you use.

@slide
  @border
    @h2
      Goal
    @h3
      @b{Minimize} the amount of time it passes between a change in the code and an execution result.

@slide
  @img(src := "img/build-tools-monsters.png", style := "border: none; box-shadow: none; width: 100%")

@slide
  @img(src := "img/bloop-logo2.png", style := "border: none; box-shadow: none; width: 90%")

@slide
  @h1
    @b{Compilation server}
  @h3
    "The new fawn in the block"

@slide
  @h2
    @b{@code{zinc++}}
  @h3
    A gap to fill in
  @h4
    @ul
      @li
        @code{scalac} gives you only cold compilation.
      @li
        @code{scalac} doesn't give you incrementality.
      @li
        @code{scalac} cannot reuse information about the build.
      @li
        Build tools are too heavyweight
      @li
        Build tools are difficult to integrate with

@slide
  @h2
    @b{Old architecture}

  @dotLR
    "Build tool A" -> "Compiler A";
    "Other CLI tools" -> "Compiler B";
    "IDE" -> "Compiler C";

@slide
  @h2
    @b{New architecture}

  @dotLR
    "Build tool A" -> "Bloop";
    "Other CLI tools" -> "Bloop";
    "IDE" -> "Bloop";

@slide
  @h2
    @b{Hot} compilers
  @h4
    What is that?

  @img(src := "img/hot-compiler.jpg", style := "border: none; box-shadow: none; width: 60%")

@slide
  @h3
    Why being @b{hot} is important
  @h4
    @ul
      @li
        Performance diff against cold compilers is critical.
      @li
        Compilers are re-used by different tools.
      @li
        We kill hot compilers more often than we think.
        @ul
          @li
            @code{sbt> reload}
          @li
            Killing accidentally the build tool.
          @li
            Every time we use sbt in different builds concurrently.

@slide
  @h2
    @b{Hot} vs @b{Cold}
  @h4
    Benchmarks in @lnk("grafana.", "https://scala-ci.typesafe.com/grafana/dashboard/db/hot-vs-cold?orgid=1")
  @br
  @ul
    @li
      Cold compilation can be up to 18x slower!
    @li
      Hot'ting the JVM is expensive, it takes:
        @ul
          @li
            CPU cycles, RAM, power (battery)...

@slide
  @h2
    @img(src := "img/poor-rick.png", style := "border: none; box-shadow: none; width: 50%")

@slide
  @h2
    Centralization
  @h4
    @blockquote
      @strong
        "One server to compile them all"
  @h4
    @ul
      @li
        Changes to the codebase have higher impact
      @li
        Easier to maintain, optimize and test

@slide
  @h2
    Integrations
  @h3
    @b{Paramount} for adoption.
  @img(src := "img/rick-morty-crying.png", style := "border: none; box-shadow: none; width: 70%")

@slide
  @blockquote
     «We created bloop to primarily support all the existing build tools that companies and Scala open-source developers use today.»
      @br
      @p
        @(fontSize := "0.75em")
        -- Us

@slide
  @ul
    @li
      Improving only sbt is @strong{not} a solution.
    @li
      Improving only new build tools is @strong{not} a solution.

@slide
  @h2
    Integrations
  @br
  @ul
    @li
      @fragment
      Supports Scala 2 and future Scala 3.
    @li
      @fragment
      Supports Scala.js and Scala Native (@lnk("open PR", "https://github.com/scalacenter/bloop/pull/485"))
    @li
      @fragment
      Build-tool-agnostic:
      @ul
        @li
          Current: sbt, maven.
        @li
          Future: bazel, gradle, pants and more!

@slide
  @h2
    Integrations
  @h3
    A command-line tool interface
  @ul
    @li
      @fragment
      Ensures snappy developer workflow

    @li
      @fragment
      Use the shell you know and love.

    @li
      @fragment
      Benefit from awesome @code{tab}-completion

      @p
        @img(src := "img/tab-completion.gif", style := "border: none; box-shadow: none; al")

@slide
  @h2
    Integrations
  @h3
    Configuration file

  @ul
    @li
      Transparent, well-specified configuration file
      @hl.diff
        {
          "project": {
            "name": "mini-bloop",
            "sources": [ "/projects/mini-bloop/src/main/scala" ],
            "dependencies": [ "my-other-project" ],
            "classpath": [ "(...)/2.12.6/scala-library-2.12.6.jar" ],
            "classesDir": "/projects/mini-bloop/.bloop/mini-bloop/scala-2.12/classes",
            "scala": { "version" : "2.12.6", (...) }
            (...)
        }

    @li
      @fragment
      Query build information from the project files.

    @li
      @fragment
      Write easy and performant scripts.

    @li
      @fragment
      @lnk("Specification of our configuration format", "https://scalacenter.github.io/bloop/docs/configuration-format/")

@slide
  @blockquote
     «In the common use case when someone is working on a customer plugin in one build and wanting to iterate on core tooling the turns arounds are seconds instead of 10+ minutes.»
      @br
      @p
        @(fontSize := "0.75em")
        -- Happy Bloop user

@slide
  @h2
    Build Server Protocol (@strong{BSP})
  @ul
    @li
      @fragment
      Another way of integration with Bloop.
    @li
      @fragment
      An LSP-like protocol to communicate with build tools.
    @li
      @fragment
      Clients are language servers and editors.
    @li
      @fragment
      More at "@lnk("Build Server Protocol and new IDEAs", "https://scala.sphere.it/")"
      @ul
        @li
          Presented by Jorge and Justin at @b{Scalasphere 2018}

@slide
  @h2
    Build Server Protocol
  @h3
    Use cases
  @ul
    @li
      @fragment
      Efficient @code{~compile} or @code{~test} from IntelliJ
    @li
      @fragment
      Editors notify modified files directly to the build tool
    @li
      @fragment
      Better integration with build tools
      @ul
        @li
          sbt, maven, bazel, et cetera

@slide
  @h2
    Pioneering use cases
  @h3
    @strong{Better optimization opportunities}
  @ul
    @li
      Knowledge about build graph enables
      @ul
        @li
          In-memory storage over writing to disk/SSD
        @li
          File watching files to invalidate caches across builds
        @li
          Parallel compilation bookkeeping (classpath or source hashing)

@slide
  @h2
    Pioneering use cases
  @h3
    @strong{Remote compilation}
  @ul
    @li
      @fragment
      Popular use case for CI servers
    @li
      @fragment
      Keep cloud instances alive for compilation jobs
    @li
      @fragment
      Requires architectural changes:
      @ul
        @li
          Independence of compile processes @br
        @li
          Deduplication of compile requests @br

@slide
  @h2
    Pioneering use cases
  @h3
    @strong{Pipelined compilation}
  @h4
    @ul
      @li
        @fragment
        Pitched in by Rory Graves at Scalasphere 2017
      @li
        @fragment
        High impact for any build graph!
      @li
        @fragment
        Restricted gains when Java compilation is required
      @li
        @fragment
        Implemented in Zinc and Bloop (for now)

@slide
  @h3
    Timeline
  @h4
    @img(src := "img/pipelined-timeline.png", style := "border: none; box-shadow: none; width: 80%")

@slide
  @h1
    Using @strong{Bloop}

@slide
  @h2
    A two-step process

  @ul
    @li
      Bloop needs configuration files to understand your build

    @li
      The configuration files are generated by your build tool

    @li
      Let's see how to get ready using Bloop

@slide
  @hl.diff
    diff --git a/project/plugins.sbt b/project/plugins.sbt
    index 278929bd0..6665ae7c9 100644
    --- a/project/plugins.sbt
    +++ b/project/plugins.sbt
    @@ -7,3 +7,4 @@ addSbtPlugin("ch.epfl.scala" % "sbt-release-early" % "2.1.1")
    +addSbtPlugin("ch.epfl.scala" % "sbt-bloop" % "1.0.0-M10")

@slide
  @h2
    @code{$ sbt bloopInstall}

@slide
  @h3
    Using Bloop

  @ul
    @li
      Bloop exposes 4 main commands:

    @li
      @fragment
      @code{bloop compile} compiles your project

    @li
      @fragment
      @code{bloop test} runs your tests

    @li
      @fragment
      @code{bloop console} opens a REPL

    @li
      @fragment
      @code{bloop run} runs your project

@slide
  @h3
    Using Bloop

  @ul
    @li
      All commands support @code{tab}-completion.

    @li
      You have access to all the features of your usual shell.

    @li
      Get help with @code{--help}

@slide
  @h1
    Compilation @strong{benchmarks}

@slide
  @h2
    @code{sbt/sbt}

  @h3
    @b{25% faster}

  @ul
    @li
      The Scala ecosystem's build tool.

    @li
      Small to medium project

    @li
      @b{800} source files, @b{50,000} lines of code, @b{20} modules

    @li
      Compiles in @b{38.05} s with sbt, or @b{28.47} s with Bloop

@slide
  @h2
    @code{guardian/frontend}

  @h3
    @b{28% faster}

  @ul
    @li
      The source for theguardian.com.

    @li
      Medium-sized project.

    @li
      @b{1,800} source files, @b{180,000} lines of code, @b{18} modules.

    @li
      Compiles in @b{88.62} s with sbt, or @b{63.42} s.

@slide
  @h2
    @code{akka/akka}

  @h3
    @b{19% faster}

  @ul
    @li
      Toolkit for building concurrent, distributed applications.

    @li
      Large project.

    @li
      @b{1,800} source files, @b{330,000} lines of code, @b{36} modules.

    @li
      Compiles in @b{263.7} s with sbt, or @b{215.7} s.

@slide
  @h2
    @code{apache/spark}

  @h3
    @b{28% faster}

  @ul
    @li
      Cluster computing system for Big Data.

    @li
      Large project.

    @li
      @b{1,800} source files, @b{400,000} lines of code, @b{24} modules.

    @li
      Compiles in @b{238.24} s with sbt, or @b{171.48} s

@slide
  @h3
    Benchmarks

  @img(src := "img/bench-charts.png", style := "border: none; box-shadow: none; width: 80%")

@slide
  @h1
    Thanks!

  @h2
    Questions?
